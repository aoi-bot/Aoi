import asyncio
import datetime
import io
import json
from typing import List, Optional, Union

import discord
from discord.ext import commands

from aoi import bot


class Messages(commands.Cog):
    def __init__(self, bot: bot.AoiBot):
        self.bot = bot

    @property
    def description(self):
        return "Commands to deal with messages"

    @commands.has_permissions(manage_messages=True)
    @commands.command(
        brief="Lists the users who have not reacted to a message",
        description="""
        noreactions https://discord.com/channels/213/12312/712129
        """,
    )
    async def noreactions(self, ctx: bot.AoiContext, msg: discord.Message):
        if msg.channel.id not in [tc.id for tc in ctx.guild.text_channels]:
            raise commands.BadArgument("Message not in server")
        m: discord.Member
        r: discord.Reaction
        lst: List[int] = []
        for r in msg.reactions:
            for u in await r.users().flatten():
                if u.id not in lst and not u.bot:
                    lst.append(u.id)
        if not lst:
            return await ctx.send_info("No one reacted")
        await ctx.paginate(
            lst=[f"<@{u.id}> | {u}" for u in ctx.guild.members if u.id not in lst],
            n=30,
            title="Members who did not react",
        )

    @commands.has_permissions(manage_messages=True)
    @commands.command(
        brief="Lists the users who have reacted to a message",
        description="""
        reactions https://discord.com/channels/213/12312/712129
        """,
    )
    async def reactions(self, ctx: bot.AoiContext, msg: discord.Message):
        if msg.channel.id not in [tc.id for tc in ctx.guild.text_channels]:
            raise commands.BadArgument("Message not in server")
        m: discord.Member
        r: discord.Reaction
        lst: List[int] = []
        for r in msg.reactions:
            for u in await r.users().flatten():
                if u.id not in lst and not u.bot:
                    lst.append(u.id)
        if not lst:
            return await ctx.send_info("No one reacted.")
        await ctx.paginate(
            lst=[f"<@{u}> | {ctx.guild.get_member(u)}" for u in lst],
            n=30,
            title="Members who reacted",
        )

    @commands.has_permissions(manage_messages=True)
    @commands.command(
        brief="Send a message with #BOT#. Use [this site](https://embed.aoibot.xyz/) to make embeds."
    )
    async def say(
        self, ctx: bot.AoiContext, channel: Optional[discord.TextChannel], *, msg: str
    ):
        channel = channel or ctx.channel
        await self.bot.send_json_to_channel(channel.id, msg, member=ctx.author)

    @commands.has_permissions(manage_messages=True)
    @commands.command(
        brief="Edit a message from #BOT#. Use [this site](https://embed.aoibot.xyz/) to make embeds."
    )
    async def edit(self, ctx: bot.AoiContext, message_id: discord.Message, *, msg: str):
        if ctx.author:
            msg = self.bot.placeholders.replace(ctx.author, msg)
        try:
            msg = json.loads(msg)
        except json.JSONDecodeError:
            msg = {"plainText": msg}
        if isinstance(msg, str):
            msg = {"plainText": msg}
        if "plainText" in msg:
            content = msg.pop("plainText")
        else:
            content = None
        if len(msg.keys()) < 2:  # no embed here:
            return await message_id.edit(content=content)
        thumbnail = msg.pop("thumbnail", None) if msg else None
        image = msg.pop("image", None) if msg else None
        msg["description"] = msg.get("description", "_ _")
        embed = discord.Embed.from_dict(msg)
        if thumbnail:
            embed.set_thumbnail(url=thumbnail)
        if image:
            embed.set_image(url=image)
        await message_id.edit(content=content, embed=embed)

    @commands.has_permissions(manage_messages=True)
    @commands.command(brief="Delete a message, after an optional number of seconds.")
    async def delete(
        self, ctx: bot.AoiContext, message: discord.Message, delay: int = 0
    ):
        await message.delete(delay=delay)

    @commands.has_permissions(manage_messages=True)
    @commands.cooldown(1, 30, commands.BucketType.channel)
    @commands.command(
        brief="Saves chat in a txt file. Limit can be a message to stop at or a number of messages"
    )
    async def savechat(
        self,
        ctx: bot.AoiContext,
        channel: Optional[discord.TextChannel],
        limit: Union[int, discord.Message],
    ):
        time = datetime.datetime.now()
        channel = channel or ctx.channel
        await ctx.trigger_typing()
        # fetch the messages first, in blocks
        current_message: Optional[discord.Message]
        if isinstance(limit, int):
            messages: List[discord.Message] = (
                await channel.history(limit=min(limit, 1000)).flatten()
            )[::-1]
        else:
            messages: List[discord.Message] = (
                await channel.history(limit=1000, after=limit).flatten()
            )[::-1]
        buf = io.StringIO()
        buf.write(
            f"Channel save of {channel.name} [{channel.id}] triggered by {ctx.author} [{ctx.author.id}] on "
            f"{datetime.datetime.now().strftime('%x %X')}. The messages go from "
            f"{messages[0].created_at.strftime('%x %X')} "
            f"to {messages[-1].created_at.strftime('%x %X')}\n\n"
        )
        seen_ids = []
        seen_dates = []
        for m in messages:
            date = m.created_at.strftime("%x")
            if date not in seen_dates:
                seen_dates.append(date)
                buf.write("=" * 10 + date + "=" * 10)
            buf.write(f"\n[{m.created_at.strftime('%X')}] ")
            if m.author.id not in seen_ids:
                seen_ids.append(m.author.id)
                buf.write(f"[{m.author} | {m.author.id}] ")
            else:
                buf.write(f"[{m.author}]")
            if m.author.bot:
                buf.write(f" [BOT]")
            content = " " + m.content
            buf.write(f":{content.splitlines(keepends=False)[0]}\n")
            buf.write(
                "\n".join(
                    f"      {line}" for line in content.splitlines(keepends=False)[1:]
                )
            )
        buf.seek(0)
        await ctx.send(
            content=f"Saved {len(messages)} in {(datetime.datetime.now() - time).seconds} s",
            file=discord.File(buf, filename="chat-save.txt"),
        )

    @commands.has_permissions(manage_messages=True)
    @commands.bot_has_permissions(manage_channels=True, manage_messages=True)
    @commands.cooldown(1, 30, commands.BucketType.channel)
    @commands.command(
        brief="Clear message from a channel",
        flags={
            "safe": (None, "Ignore pinned messages"),
            "from": (discord.Member, "From a certain member"),
        },
    )
    async def clear(self, ctx: bot.AoiContext, n: int):  # noqa C901
        await ctx.trigger_typing()
        # fetch the messages first, in blocks
        messages: List[discord.Message] = []
        channel: discord.TextChannel = ctx.channel
        last_message: Optional[discord.Message] = None
        current_message: Optional[discord.Message]
        reached_bulk_limit = False
        now_timestamp = discord.utils.snowflake_time(ctx.message.id)
        log = False
        if n > 100 or ("from" in ctx.flags and n > 50):
            log = True
            msg = await ctx.send("Fetching messages...")

        while len(messages) < n and not reached_bulk_limit:
            async for current_message in channel.history(
                limit=min(100, n - len(messages)), before=last_message
            ):
                if current_message.id == ctx.message.id:
                    continue
                if log and current_message.id == msg.id:
                    continue
                last_message = current_message
                if (
                    now_timestamp - discord.utils.snowflake_time(current_message.id)
                ).days >= 13:
                    reached_bulk_limit = True
                    break
                if "safe" in ctx.flags and current_message.pinned:
                    continue
                if "from" not in ctx.flags or (
                    "from" in ctx.flags
                    and ctx.flags["from"].id == current_message.author.id
                ):
                    messages.append(current_message)
            if log:
                await msg.edit(content=f"Fetching messages...{len(messages)}/{n}")
            if len(messages) < n and not reached_bulk_limit:
                await asyncio.sleep(1)

        to_delete = [
            messages[i * 100 : (i + 1) * 100]
            for i in range((len(messages) + 100 - 1) // 100)
        ]

        for n, row in enumerate(to_delete):
            if log:
                await msg.edit(content=f"Deleting batch {n + 1}/{len(to_delete)}")
            if len(row) == 0:
                continue
            if len(row) == 1:
                await row[0].delete()
                continue
            await self.bot.http.delete_messages(
                ctx.channel.id,
                message_ids=[m.id for m in row],
                reason=f"Bulk | {n + 1}/{len(to_delete)} | "
                f"{ctx.author} ({ctx.author.id})",
            )
            await asyncio.sleep(1)

        ignore_pins = ", while ignoring pins" if "safe" in ctx.flags else ""
        from_user = f"from {ctx.flags['from'].mention}" if "from" in ctx.flags else ""
        confirmation = f"Done! Cleared {len(messages)} {from_user}{ignore_pins}. " + (
            "The 14 day limit was hit." if reached_bulk_limit else ""
        )

        if log:
            await msg.delete()

        msg = await ctx.send_ok(confirmation)
        await asyncio.sleep(3)
        await msg.delete(delay=3)
        try:
            await ctx.message.delete(delay=3)
        except discord.Forbidden:
            pass


def setup(bot: bot.AoiBot) -> None:
    bot.add_cog(Messages(bot))
